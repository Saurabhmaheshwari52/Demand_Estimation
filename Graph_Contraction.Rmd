---
title: "Directed Network Graph Formation"
author: "Saurabh Maheshwari"
date: "May 8, 2018"
output: html_document
---
*Let the file load, graphs may take a while to appear*

### Objective

The aim of this project is to automate the process of directed network graph formation, i.e., creation of incidence matrix, node adjacency matrix,and map the sensors to appropriate links. The data used for creating the freeway network is obtained from open street maps, whereas, the data for sensors is obtained from PeMS. The results of the algorithm will be fed to the network sensor error estimation algorithm, that quantifies the erroneous sensors using network statistics.

### Major libraries used

**Osmar** - To import data from open street maps  
**Leaflet**, **mapview**, **sp** - Mapping the network  
**dplyr**, **plyr** - To manipulate data frames  

### Methodology
```{r, include=FALSE}
{
  library(osmar)
  library(sp)
  library(mapview)
  library(dplyr)
  library(leaflet)
}
setwd("F:/Old_Desktop/UC Davis/Research GSR/Networked graph/bin")
load("Orange.Rdata")

{
  #bbox = corner_bbox(-118.1174,33.5076,-117.5056,33.9462) # orange county
  bbox = corner_bbox(-118.0042, 33.6363, -117.7226, 33.9194)
  #src = osmsource_osmosis(file = "california-latest.osm", osmosis = "osmosis")
  #data = get_osm(bbox, source = src)
  hw_ids = find(data, way(tags(k %grep% "highway" & v %grep% "motorway"
  )))
  hw_ids = find_down(data, way(hw_ids))
  hw = subset(data, ids = hw_ids)
  hw_lines = as_sp(hw, "lines")
  hw_nodes = as_sp(hw, "points")
}
```
**Creating the map required**  
We start by downloading the bulk osm data for California (approx. 18GB). Next, using osmar library, we extract the required data using a bounding box, demarcating the latitude and longitude boundaries.  
*bbox = corner_bbox(-118.0042, 33.6363, -117.7226, 33.9194)*  
Then extracting only the freeway information (links and nodes) from the resulting data, the following network is created:  
```{r}
# hw_lines contain extracted link data
# hw_nodes contain extracted node data
mapview(hw_lines) + mapview(hw_nodes, color = "black", cex = 1)
```
Looking closely, we see numerous nodes and links. To be exact, this graph consists of:  
```{r}
print(paste("number of nodes: ", length(unique(hw_nodes@data$id))))
print(paste("number of links: ", length(unique(hw_lines@data$id))))
```
The problem here is that most of the links contain more than two nodes, which would make the incidence matrix unnecessarily large. Thus, we extract the nodes that connect two links, and map them over the links. The updated map looks as follows:
```{r, include=FALSE}
{
  uniw = unique(hw$ways$attrs$id)
  node_req = c()
  for (i in 1:length(uniw)){
    nodesw = hw$ways$refs$ref[which(hw$ways$refs$id == uniw[i])]
    nodesw = nodesw[which(nodesw %in% hw$nodes$attrs$id)]
    if(length(nodesw)>1){
      nodesw_hw = c(nodesw[1], nodesw[length(nodesw)])
      node_req = c(node_req, nodesw_hw)
    }
  }
  hp_req = find_up(hw, node(unique(node_req)))
  hp = subset(hw, ids = hp_req)
  hp_req_sp = as_sp(hp, "points")
}
```
```{r}
# hp_req_sp contains only the required nodes
mapview(hw_lines) + mapview(hp_req_sp, color = "black", cex = 1)
```
Now, the number of nodes have decreased substantially to:
```{r}
print(paste("number of nodes: ", length(unique(hp_req_sp@data$id))))
```
**Creating the incidence matrix**  
To create the incidence matrix, each link was looked up for the first and last node incident on it, keeping in mind the direction. The rows represent nodes, whereas the columns represent links. +1 was assigned at the head and -1 to the tail of the link, all other entries to 0. The incidence matrix has a dimension of 2973 by 2640. Here, only first 10 rows and 5 columns of the incidence matrix are shown for illustration purpose.
```{r, include=FALSE}
load("LinkMat.Rdata")
```

```{r}
LinkMat[1:10, 1:5]
```
**Assigning links to appropriate freeways**  
The osm data does not explicitly mention about which freeway is a particular link part of. For example, the link with id "391666573" has the following tags attached to it:
```{r}
hw$ways$tags[which(hw$ways$tags$id == "391666573"),]
```
Thus, for the freeway links a combination of "name" and "ref" tag was used to obtain the information about the freeway as follows. 
```{r, include=FALSE}
MetaData = read.table(
    "F:/Old_Desktop/UC Davis/Research GSR/Station_Hr_Data/MetaData/d012_text_meta.txt",
    header = TRUE,
    sep = "\t",
    fill = TRUE)
NodeMat = hp$ways$ref %>% filter(id %in% names(LinkMat))
```
```{r, warning=FALSE}
Fwy = lapply(unique(NodeMat$id), function(x) {
  a = hp$ways$tags %>% filter(id == x)
  if (a$v[which(a$k == "highway")] == "motorway") {
  a = a %>% filter(k == "ref" | k == "name")
  }
})
Fwy = plyr::ldply(Fwy, as.data.frame)
FwynameList = as.vector(unique(Fwy$v[which(Fwy$k == "name")]))
FwynameList = cbind(
FwynameList,
c(
"CA 22",
"CA 55",
"CA 133 Toll",
"I 5",
"I 405",
"CA 133",
"CA 241 Toll",
"CA 91",
"CA 91",
"CA 73",
"CA 57",
"CA 91 Toll",
"CA 90",
"CA 73 Toll"
)
)
FwynameList_rep = FwynameList[match(Fwy$v, FwynameList[, 1]), 2]
Fwy$v[!is.na(FwynameList_rep)] = FwynameList_rep[!is.na(FwynameList_rep)]
Fwy = Fwy %>% group_by(id) %>% filter(row_number() == 1) %>% ungroup()
Fwy = Fwy[, -2]
Fwy = Fwy %>% mutate(Fwyno = as.numeric(grep("[0-9]",
unlist(
strsplit(as.character(v), split = " ")
),
value = TRUE))) %>%
arrange(Fwyno) %>% select(-v) %>% mutate(dir = rep(0, nrow(Fwy)))
```
Thus, a data frame named "Fwy" was created that contained the information about which freeway the links belonged to. First 5 rows are shown here for illustration purposes:
```{r}
Fwy[1:5, 1:2]
```
```{r, include=FALSE}
n = as.numeric(names(Fwy))
SensorData = MetaData %>% filter(Fwy %in% n) %>% arrange(Fwy)
SensorData = split(SensorData, SensorData$Fwy)
Fwy = Fwy[which(names(Fwy) %in% names(SensorData))]
Meta_type = split(MetaData, MetaData$Type)
```
**Adding ramps to the Fwy data frame**  
So far, we only have freeway links assigned to the appropriate freeways. Now, we would like to add the immediate links that go off or on the freeway, aka ramps, to the data frame Fwy. This is done by checking for each node on the freeway segment, out of the links it is incident upon, which one is tagged as "motorway-link" in the osm data. If there is such a link, it was added to the Fwy data set with appropriate freeway values.      
**Overlapping sensors over the network**  
The sensor data is now used to add a layer over the existing graph to help visualize the complete network. Different types of sensors are grouped separately and can be viewed as per user's choice by clicking the check boxes. The legend shows the color used for each sensor type. Hovering upon the sensor, link or node highlights their IDs. By default, main line (ML) sensors are checked.
```{r, message=FALSE, warning=FALSE}
p = leaflet() %>% addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>%
  addPolylines(
  data = hw_lines,
  highlightOptions = highlightOptions(color = "red"),
  label = as.character(hw_lines$id)
  ) %>%
  addCircleMarkers(
  data = hp_req_sp,
  radius = 0.3,
  col = "black",
  label = ~ as.character(id)
  )
  cols = c("white", "cyan", "magenta", "pink", "orange", "green", "red")
  pal = colorFactor(cols, unique(MetaData$Type))
  purrr::walk(names(Meta_type), function(x) {
  dat = Meta_type[[x]]
  p <<- p %>%
  addCircleMarkers(
  data = dat,
  radius = 3,
  col = pal(x),
  popup = c(
  paste(
  as.character(dat$ID),
  as.character(dat$Type),
  as.character(dat$User_ID_1),
  as.character(dat$Name)
  )
  ),
  group = x,
  fillOpacity = 0.5,
  opacity = 0.8
  )
  })
  p = p %>% addLayersControl(overlayGroups = names(Meta_type),
  options = layersControlOptions(collapsed = FALSE)) %>%
  hideGroup(names(Meta_type)[-which(names(Meta_type) == "ML")]) %>%
  leaflet::addLegend(
  position = "bottomright",
  pal = pal,
  values = names(Meta_type),
  title = "Sensors"
  )
  p
```
```{r, message=FALSE, warning=FALSE, include=FALSE}
load("PreMap.RData")
```
**Mapping sensors to the appropriate links**  
Currently, by visualization we can figure out the link that contains a particular sensor. As PeMS sensor metadata does not interact with the osm data, the link-sensor relation is unknown. We need to create an algorithm such that each sensor automatically gets mapped to the link using the geographical properties.  
The algorithm for mapping sensors to the links is as follows: 

1. For each sensor location, extract all the links on the freeway segment in the direction sensor is installed  
2. For the nodes on each link, calculate 3 distances   
    a) Distance between the nodes (d1)  
    b) Distance between first node and sensor (d2)  
    c) Distance between last node and sensor  
3. Calculate d1 - (d2+d3), call it d4  
4. Calculate d4 for each link, and arrange d4 in ascending order  
5. The link for which d4 is smallest and lesser than a threshold (1e-4 in this case), assign it the sensor  
6. Repeat the above steps for each sensor location  

Finally, the results are stored as a form of a list (linkId). For illustration purpose, 5 ML sensors on I-5, highlighted on the map, are shown below with the appropriate link chosen by the algorithm. One can verify the IDs by hovering above the links in the map and cross checking with the table that appears below. 
```{r, message=FALSE, warning=FALSE}
sensors = c("1204701", "1204759", "1204823", "1205035", "1205060")
q = p %>% addCircleMarkers(lng = MetaData$Longitude[which(MetaData$ID %in% sensors)], lat = MetaData$Latitude[which(MetaData$ID %in% sensors)], color = "black", label = as.character(MetaData$ID[which(MetaData$ID %in% sensors)]))
sensor_data = linkId[[1]][which(linkId[[1]]$V2 %in% sensors), c(1,2)]
names(sensor_data) = c("Link ID", "Sensor ID")
sensor_data
q
```
**Re-mapping ramp and freeway-freeway sensors**  
Looking closely, one would figure out that the ramp sensors (OR/FR) are located on the freeways rather than ramps. Same for freeway-Freeway (FF) sensors. This was one of the tedious challenges I encountered in this project. But with a combination of a simple algorithm and manual work, the sensors were remapped. The details are omitted in this document. In the map below, all the remapped sensors are shown on their appropriate new links.
```{r, echo=FALSE, message=FALSE, warning=FALSE}
load("linkId_cum.Rdata")
load("LinkMat_Final.RData")
load("sensor_new_coord.Rdata")
p = leaflet() %>% addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>%
  addPolylines(data = hw_lines, highlightOptions = highlightOptions(color = "red"),
               label = as.character(hw_lines$id)) %>%
  addCircleMarkers(data = hp_req_sp, radius = 0.3, col = "black",
                   label = ~as.character(id))
cols = c("white", "cyan", "pink", "orange", "green","red")
pal = colorFactor(cols, names(sensor_new_coord))
purrr::walk(names(sensor_new_coord), function(x) {
  dat = sensor_new_coord[[x]]
  p <<- p %>%
    addCircleMarkers(
      data = dat,
      radius = 3,
      col = pal(x),
      popup = c(paste(
        as.character(dat$id),
        as.character(dat$type),
        as.character(linkId_cum$V1[which(linkId_cum$V2 %in% dat$id)])
      )),
      group = x,
      fillOpacity = 0.5,
      opacity = 0.8
    )})
p = p %>% addLayersControl(overlayGroups = names(sensor_new_coord),
                           options = layersControlOptions(collapsed = FALSE)) %>%
  hideGroup(names(sensor_new_coord)[-which(names(sensor_new_coord) == "ML")]) %>%
  leaflet::addLegend(position = "bottomright", 
                     pal = pal,
                     values = names(sensor_new_coord),
                     title = "Sensors")
p

```
**Creating the adjacency matrix**  
To create adjacency matrix, for each link, nodes having 1 or -1 were searched in the incidence matrix. The cell corresponding to these nodes in the adjacency matrix was assigned 1, else 0. For illustration, first 10 rows and 10 columns of adjacency matrix are shown below:
```{r, include=FALSE}
Node_Node = matrix(0, nrow = nrow(LinkMat), ncol = nrow(LinkMat))
rownames(Node_Node) = rownames(LinkMat)
colnames(Node_Node) = rownames(LinkMat)
for (i in 1:ncol(LinkMat)){
  node = sort(which(LinkMat[,i] %in% c(+1, -1)))
  Node_Node[node[1], node[2]] = 1
}
Node_Node[lower.tri(Node_Node)] = t(Node_Node)[lower.tri(Node_Node)]
```
```{r}
Node_Node[1:10, 1:10]
```
### Conclusion  
The results of this project, namely, incidence matrix, adjacency matrix and link-sensor relation data frame were used for the network sensor error estimation algorithm. This project led to the application of the error estimation algorithm on large networks, which is expected to result in an important contribution to the field of sensor bias estimation.









